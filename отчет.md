# ABC_IDZ_3
Вариант №19

# Отчет
## задание на 4 и 5 баллов:
### _Опции компляции:_
Компиляция программы без оптимизирующих и отладочных опций:
```sh
gcc -S -masm=intel foo1.c
```
Компиляция программы с доп. опциями с целью убрать лишние макросы:
```sh
gcc -masm=intel -fno-asynchronous-unwind-tables -fno-jump-tables -fno-stack-protector -fno-exceptions foo1.c -S -o foo1.s
```

Описание опций компиляции:
- -fno-asynchronous-unwind-tables - делает программу меньше по размеру, уменьшая EH-секцию
- -fno-jump-tables - предотвращает генерирование джамп-таблиц для конструкций switch
- -fno-stack-protector - отключение защиты стека от несанкционированного доступа (например, канарейка)
- -fno-exceptions - отключение обработки исключений у функций

Компиляция и компоновка ассемблерной программы без использования опций отладки:
```sh
as -o foo1.o foo1.s
gcc foo1.o
```
### _Опции компляции для многофайловой программы (она была написана сразу же):
Компиляция файлов foo1.c & foo2.c оптимизирующими и отладочными опциями:
```sh
gcc -masm=intel -O0 -fno-asynchronous-unwind-tables -fno-jump-tables -fno-stack-protector -fno-exceptions foo1.c -S -o foo1.s

gcc -masm=intel -O0 -fno-asynchronous-unwind-tables -fno-jump-tables -fno-stack-protector -fno-exceptions foo2.c -S -o foo2.s
```
Ассемблирование программ (с целью рефакторинга):
```sh
gcc foo1.s -c -o foo1.o
gcc foo2.s -c -o foo2.o
```
Компоновка и линковка в исполняемый файл:
```sh
gcc foo1.o foo2.o -o foo.out
```
Необходимые файлы предствлены в папке 9_points, комментарии добавлены к оптимизированной версии (она на 99% совпадает с неоптимизированной, см соотвествтвующие папки в папке 9_points).

### _Тестовые прогоны:_
Скриншот запуска тестов на обоих программах:
![Тесты на оценку 4 и 5](/tests/Tests_1_part.png)

## задание на 6 баллов:

### С этого пункта и дальше см. файлы в папке diffrenent files (в папке 9_points).

Сделано максимальное использование регистров вместо ОЗУ для хранения лок. переменных (и аргументов, которые требуются для вычисления функции). Комментарии предоставлены в файле foo1.s & foo2.s в папке 9_points. Сишные файлы остались без изменений.
Размеры программ на языке ассембелра с модифицированной программой (дополнение регистров) примерно равны, их отличие - оптимизированная программа рабоатет быстрее (см. предыдущий пункт).
Однако оптимизированная програма (с помощью флагов оптимизации) занимает меньше строк в редакторе, нежели программа, скомпилированная стандратным путем, без опций оптимизации.

## задание на 7 баллов:
В командной строке принимаются 3 аргумента - номер варианта входа данных (через файлы - 1, через генератор псевдослучайных строк - 2), второй аргумент - либо название входного файла (в случае ввода через файлы), либо seed для генератора (в случае выбора ввода по 2-ому варианту), третий параметр командной строки - название выходного файла. Файлы имеют стандартное расширение .txt, файл input.txt должен присутствовать.

## задание на 8 баллов:
Все необходимые модификации были сделаны в пунктах выше (включая прогоны, на одном из которых время выполнения превышает 1 сек благодаря зацикливанию вычислющего результат кода).

## задание на 9 баллов:
Указанные в задании тесты уже проводились (см. выше), производительность уже была отражена (количество секунд было выведено в консоль). Размер испольняемого файла - в случае оптимизированной программы это 16,6 кБ (16 552 байта), в случае неоптимизированной - 16,6 кБ (16 608 байт). Отличие в данном случае небольшое, но и программа невелика. Размер ассемблерного кода: в случае оптимизированной программы это 365 строчек в основном файле (foo1.s) и 74 строки в побочном файле (foo2.s), в случае программы без оптимизаций - 375 строчек в основном файле (foo1.s) и 71 строка в побочном файле (foo2.s).
P.S. Оптимизации по скорости и размеру в данном случае практически равносильны. Так как программа небольшая, это утверждение корректно.

